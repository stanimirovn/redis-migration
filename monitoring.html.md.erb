---
title: Monitoring Redis for VMware Tanzu Application Service
owner: London Services
---

<strong><%= modified_date %></strong>

## <a id="loggregator"></a>Loggregator

Redis metrics are emitted through Loggregator via the [Reverse Log Proxy](https://github.com/cloudfoundry/loggregator/blob/master/docs/rlp_gateway.md) and [Log Cache](https://github.com/cloudfoundry/log-cache/blob/master/README.md). You can use third-party monitoring tools to consume Redis metrics to monitor Redis performance and health.
<a id="firehose"></a>The [Loggregator Firehose](https://docs.pivotal.io/pivotalcf/loggregator/architecture.html#firehose) endpoint is being deprecated.

As an example of how to display KPIs and metrics without the Firehose, see the
[CF Redis example dashboard](https://github.com/pivotal-cf/metrics-datadog-dashboard) in GitHub.
This example uses [Datadog](https://www.datadoghq.com).
However, VMware does not endorse or support any third-party solution.

## <a id="polling"></a> Metrics Polling Interval

The metrics polling interval defaults to 30 seconds.
You can change this by navigating to the Metrics configuration page in <%= vars.ops_manager %>
and entering a new value in **Metrics polling interval (min: 10)**.

<%= image_tag("metrics_polling.png",
:alt => "Screenshot of the metrics polling interval field. The minimum value allowed is ten seconds.",
:width => "300") %>

Metrics are emitted in the following format:

<pre class=terminal>
origin:"p-redis" eventType:ValueMetric timestamp:1480084323333475533 deployment:"cf-redis" job:"cf-redis-broker" index:"{redacted}" ip:"10.0.1.49" valueMetric:&#60;name:"_p_redis_service_broker_shared_vm_plan_available_instances" value:4 unit:"" >
</pre>

## <a id="critical-logs"></a>Critical Logs
VMware recommends operators set up alerts on critical logs to help prevent further
degradation of the Redis service. For examples of critical logs for service backups,
including log messages for failed backups, backups with errors, and backups that
failed to upload to destinations, see <a href="https://docs.pivotal.io/svc-sdk/service-backup/18-1/#troubleshooting">Troubleshooting</a> in the Service Backups documentation.

## <a id="healthwatch"></a>Healthwatch

The Healthwatch service monitors and alerts on the current health, performance,
and capacity of your service instances.
By default, the Healthwatch dashboard displays core metrics and alerts
configured for recommended thresholds.

For more information, see
[Using Healthwatch](https://docs.pivotal.io/platform/healthwatch/using.html).

## <a id="kpi"></a>Key Performance Indicators

Key Performance Indicators (KPIs) for <%= vars.product_full %> are metrics that operators find most useful for monitoring their Redis service to ensure smooth operation.
KPIs are high-signal-value metrics that can indicate emerging issues. KPIs can be raw component metrics or _derived_ metrics generated by applying formulas to raw metrics.

VMware recommends the following KPIs for general alerting and response with typical <%= vars.product_short %> installations.
If using Healthwatch, some core metrics are configured by default using the recommended thresholds below.
VMware recommends that operators continue to fine-tune the alert measures to their installation by observing historical trends.
VMware also recommends that operators expand beyond this guidance and create new, installation-specific monitoring
metrics, thresholds, and alerts based on learning from their own installations.

For how to create custom service alerts for Healthwatch, see [Configuring Healthwatch Alerts](https://docs.pivotal.io/platform/healthwatch/api/alerts.html).

For a list of all other Redis metrics, see [Other Redis Metrics](#other-metrics) below.

### <a id="Redis-service-KPIs"></a> <%= vars.product_short %> KPIs
#### <a id="total-od-instances"></a> Total Instances For On-Demand Service

<table>
   <tr><th colspan="2" style="text-align: center;"><br> total_instances <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Total instances provisioned by app developers across all On-Demand Services and for a specific On-Demand plan
      <br><br>
      <strong>Use</strong>: Track instance use by app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Daily</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: N/A  <br>
      <strong>Red critical</strong>: N/A </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      N/A
      </td>
   </tr>
</table>

#### <a id="quota-remaining-od-instances"></a> Quota Remaining For On-Demand Service

<table>
   <tr><th colspan="2" style="text-align: center;"><br> quota_remaining <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
       <td>Number of available instances across all On-Demand Services and for a specific On-Demand plan.
      <br><br>
      <strong>Use</strong>: Track remaining resources available for app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Daily</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: 3  <br>
      <strong>Red critical</strong>: 0 </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Increase quota allowed for the specific plan or across all on-demand services.
      </td>
   </tr>
</table>

#### <a id="total-shared-instances"></a> Total Instances For Shared-VM Service

<table>
   <tr><th colspan="2" style="text-align: center;">
   <br>_p_redis_service_broker_shared_vm_plan_total_instances <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Total instances provisioned for Shared-VM Services.
      <br><br>
      <strong>Use</strong>: Track total Shared-VM instances available for app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>App-specific</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: N/A  <br>
      <strong>Red critical</strong>: N/A </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      N/A
      </td>
   </tr>
</table>

### <a id="Redis-KPIs"></a> Redis KPIs

The metrics in this section can be used for on-demand and shared-VM service instances.
You can differentiate between these service instance metrics as follows:

* **On-Demand service instances:**
  * Have origin <code>p.redis</code>

* **Shared-VM service instances:**
  * Have origin <code>p-redis</code>
  * Their names are
pre-pended with <code>_p_redis_shared_vm_SHARED_INSTANCE_GUID/</code>.
  <code>SHARED-INSTANCE-GUID</code> can be retrieved by running <code>cf service SERVICE-NAME --guid</code>.

#### <a id="persistent-disk-percent"></a> Percent of Persistent Disk Used

<table>
   <tr><th colspan="2" style="text-align: center;"><br> disk.persistent.percent <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Percentage of persistent disk being used on a VM. The persistent disk is specified as an IaaS-specific disk type with a size. For example, <code>pd-standard</code> on GCP, or <code>st1</code> on AWS, with disk size 5&nbsp;GB.
        This is a metric relevant to the health of the VM. A percentage of disk usage approaching 100 causes the VM disk to become unusable as no more files are allowed to be written.
      <br><br>
      <strong>Use</strong>: Redis is an in-memory datastore that uses a persistent disk to backup and restore the dataset in case of upgrades and VM restarts.
      <br><br>
      <strong>Origin</strong>:  BOSH HM<br>
      <strong>Type</strong>: percent<br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: >75 <br>
      <strong>Red critical</strong>: >90 </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Ensure that the disk is at least 2.5x the VM memory for the on-demand broker and 3.5x the VM memory for cf-redis-broker. If it is, then contact VMware Tanzu Support. If it is not, then increase disk space.
      </td>
   </tr>
</table>

#### <a id="used-memory-max-memory"></a> Used Memory Percent

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.memory.used_memory / info.memory.maxmemory  <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>The ratio of these two metrics returns the percentage of available memory used:<br>
         <ul>
           <li><code>info.memory.used_memory</code> is a metric of the total number of bytes allocated by Redis using its allocator (either standard libc, jemalloc, or an alternative allocator such as tcmalloc).</li>
           <li><code>maxmemory</code> is a configuration option for the total memory made available to the Redis instance.</li>
         </ul>
      <strong>Use</strong>: This is a performance metric that is most critical for Redis instances with a <code>maxmemory-policy</code> of <code>allkeys-lru</code>
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: percentage <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>App-specific based on velocity of data flow. Some options are:
      <br><br>
      <ol>
      <li>Individual data points---Use if key eviction is in place, for example, in cache use cases.</li>
      <li>Average over last 10 minutes---Use if this gives you enough detail.</li>
      <li>Maximum of last 10 minutes</li></ol>

If key eviction is not in place, options 1 or 3 give more useful information to ensure that high usage triggers an alert.</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: 80%
Not applicable for cache usage. When used as a cache, Redis typically uses up to maxmemory and then evict keys to make space for new entries.
<br><br>
A different threshold might be appropriate for specific use cases of no key eviction, to account for reaction time. Factors to consider:<br><br>
<ol>
<li>Traffic load on app---Higher traffic means that Redis memory fills up faster.</li>
<li>Average size of data added/ transaction---The more data added to Redis on a single transaction, the faster Redis fills up its memory.</li></ol>

<strong>Red critical</strong>: 90%. See warning-specific threshold information.
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      No action assuming the maxmemory policy set meets your apps needs. If the maxmemory policy does not persist data as you want, either coordinate a backup cadence or update your maxmemory policy if using the on-demand Redis service.
      </td>
   </tr>
</table>

#### <a id="connected-clients"></a> Connected Clients

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.clients.connected_clients <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Number of clients currently connected to the Redis instance.<br><br>
         <strong>Use</strong>: Redis does not close client connections. They remain open until closed explicitly by the client or another script. Once the <code>connected_clients</code> reaches <code>maxclients</code>, Redis stops accepting new connections and begins producing <code>ERR max number of clients reached</code> errors.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: number <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: App-specific. When connected clients reaches max clients, no more clients can connect. This alert must be at the level where it can tell you that your app has scaled to a certain level and can require action.<br>
      <strong>Red critical</strong>: App-specific. When connected clients reaches max clients, no more clients can connect. This alert must be at the level where it can tell you that your app has scaled to a certain level and can require action.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Increase max clients for your instance if using the on-demand service, or reduce the number of connected clients.
      </td>
   </tr>
</table>

#### <a id="blocked-clients"></a> Blocked Clients

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.clients.blocked_clients <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>The number of clients currently blocked waiting for a blocking request they have made to the Redis server. Redis provides two types of primitive commands to retrieve items from lists: standard and blocking. This metric concerns the blocking commands.<br><br>

         <strong>Standard Commands</strong><br><br>
      The standard commands (LPOP, RPOP, RPOPLPUSH) immediately return an item from a list. If there are no items available the standard pop commands return nil.<br><br>

      <strong>Blocking Commands</strong><br><br>
      The blocking commands (BLPOP, BRPOP, BRPOPLPUSH) wait for an empty list to become non-empty.
      The client connection is blocked until an item is added to the lists it is watching. Only the client that made the blocking request is blocked, and the Redis server continues to serve other clients.
      <br><br>The blocking commands each take a <code>timeout</code> argument that is the time in seconds the server waits for a list before returning nil. A blocking command with timeout <code>0</code> waits forever. Multiple clients can be blocked waiting for the same list. For details of the blocking commands, see: <a href="https://redis.io/commands/blpop">https://redis.io/commands/blpop</a>.
      <br><br>
      <strong>Use</strong>: Blocking commands can be useful to avoid clients regularly polling the server for new data. This metric tells you how many clients are currently blocked due to a blocking command.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: number <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>App-specific. Change from baseline can be more significant than actual value.</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: The expected range of the <code>blocked_clients</code> metric depends on what Redis is being used for:
<ul>
<li>Many uses have no need for blocking commands and expect <code>blocked_clients</code> to always be zero.</li>
<li> If blocking commands are being used to force a recipient client to wait for a required input, a raised <code>blocked_clients</code> might suggest a problem with the source clients.</li>
<li> <code>blocked_clients</code> might be expected to be high in situations where Redis is being used for infrequent messaging.</li>
</ul>
If <code>blocked_clients</code> is expected to be non-zero, warnings could be based on change from baseline. A sudden rise in <code>blocked_clients</code> could be caused by source clients failing to provide data required by blocked clients.<br><br>
      <strong>Red critical</strong>: There is no <code>blocked_clients</code> threshold critical to the function of Redis.

However a problem that is causing <code>blocked_clients</code> to rise might often cause a rise in <code>connected_clients</code>.
<code>connected_clients</code> does have a hard upper limit and should be used to trigger alerts.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Analysis could include:<br><br>
        <ul>
<li>Checking the <code>connected_clients</code> metric. <code>blocked_clients</code> would often rise in concert with <code>connected_clients</code>.</li>
<li>Establishing whether the rise in <code>blocked_clients</code> is accompanied by an overall increase in apps connecting to Redis, or by an asymmetry in clients providing and receiving data with blocking commands</li>
<li>Considering whether a change in <code>blocked_clients</code> is most likely caused by oversupply of blocking requests or undersupply of data</li>
<li>Considering whether a change in network latency is delaying the data from source clients</li></ul>

In general, a rise or change in <code>blocked_clients</code> is more likely to suggest a problem in the network or infrastructure, or in the function of client apps, rather than a problem with the Redis service.
      </td>
   </tr>
</table>

#### <a id="memory-fragmentation-ratio"></a> Memory Fragmentation Ratio

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.memory.mem_fragmentation_ratio <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Ratio of the amount of memory allocated to Redis by the OS to the amount of memory that Redis is using
      <br><br>
      <strong>Use</strong>: A memory fragmentation less than one shows that the memory used by Redis is higher than the OS available memory. In other packagings of Redis, large values reflect memory fragmentation. For <%= vars.product_short %>, the instances only run Redis, meaning that no other processes are affected by a high fragmentation ratio (e.g., 10 or 11).
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: ratio <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: < 1. Less than 1 indicates that the memory used by Redis is higher than the OS available memory which can lead to performance degradations. <br>
      <strong>Red critical</strong>: Same as warning threshold.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Restart the Redis server to normalize fragmentation ratio.
      </td>
   </tr>
</table>

#### <a id="instantaneous-ops-per-sec"></a> Instantaneous Operations Per Second

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.stats.instantaneous_ops_per_sec <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>The number of commands processed per second by the Redis server. The <code>instantaneous_ops_per_sec</code> is calculated as the mean of the recent samples taken by the server. The number of recent samples is hardcoded as 16 in the implementation of Redis.
      <br><br>
      <strong>Use</strong>: The higher the commands processed per second, the better the performance of Redis. This is because Redis is single threaded and the commands are processed in sequence. A higher throughput would thus mean faster response per request which is a direct indicator of higher performance. A drop in the number of commands processed per second as compared to historical norms could be a sign of either low command volume or slow commands blocking the system. Low command volume could be normal, or it could be indicative of problems upstream.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Every 30 seconds</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: A drop in the count compared to historical norms could be a sign of either low command volume or slow commands blocking the system. Low command volume could be normal, or it could be indicative of problems upstream. Slow commands could be due to a latency issue, a large number of clients being connected to the same instance, memory being swapped out, etc. Thus, the count is possibly a symptom of compromised Redis performance. However, this is not the case when low command volume is expected.<br><br>
      <strong>Red critical</strong>: A very low count or a large drop from previous counts might indicate a downturn in performance that should result in an investigation. That is unless the low traffic is expected behavior.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        A drop in the count can be a symptom of compromised Redis performance. The following are possible responses:
   <br><br>
<ol>
   <li>
      <strong>Identify slow commands using the slowlog:</strong><br>
      Redis logs all the commands that take more than a specified amount of time in slowlog.
      By default, this time is set to 20ms and the slowlog is allowed a maximum of 120 commands.
      For the purposes of slowlog, execution time is the time taken by Redis alone and does not account for time spent in I/O.
      So it would not log slow commands solely due to network latency.
      <br><br>
      Given that typical commands, including network latency, take about 200ms, a 20ms Redis execution time is 100 times slower.
      This could be indicative of memory management issues wherein Redis pages have been swapped to disk.
      <br><br>
      To see all the commands with slow Redis execution times, type <code>slowlog get</code> in the redis-cli.
   </li>

   <li>
      <strong>Monitor client connections:</strong><br>
      Because Redis is single threaded, one process services requests from all clients.
      As the number of clients grows, the percentage of resource time given to each
      client decreases and each client spends an increasing time waiting for their share of Redis server time.
      <br><br>
      Monitoring the number of clients can be important because there might be apps
      creating connections that you did not expect or your app might not be efficiently closing unused connections.
      <br><br>
      The connected clients metrics can be used to monitor this.
      This can also be viewed from the redis-cli using the command <code>info clients</code>.</li>

      <li><strong>Limit client connections:</strong><br>
      This currently defaults to 10000, but depending on the app, you might want to limit this further.
      To do this, run <code>CONFIG SET maxclients NUMBER-OF-CONNECTIONS</code> in the redis-cli.
      You can configure this for On-Demand service instances in <%= vars.ops_manager %>.
      Connections that exceed the limit are rejected and closed immediately.
      <br><br>
      It is important to set <code>maxclients</code> to limit the number of unintended client connections.
      Set <code>maxclients</code> to 110% to 150% of your expected peak number of connections.
      In addition, because an error message is returned for failed connection attempts,
      the maxclient limit warns you that a significant number of unexpected connections are occurring.
      This helps maintain optimal Redis performance.
   </li>

   <li>
      <strong>Improve memory management:</strong><br>
      Poor memory can cause increased latency in Redis.
      If your Redis instance is using more memory than is available,
      the operating system swaps parts of the Redis process from out of physical memory and on to disk.
      Swapping significantly reduces Redis performance because reads from disk are
      about five orders or magnitude slower than reads from physical memory.
   </li>
</ol>


      </td>
   </tr>
</table>

#### <a id="keyspace-hits-keyspace-misses"></a> Keyspace Hits / Keyspace Misses + Keyspace Hits

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.stats.keyspace_hits / info.stats.keyspace_misses + info.stats.keyspace_hits <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      <td>Hit ratio to determine share of keyspace hits that are successful
      <br><br>
      <strong>Use:</strong> A small hit ratio (less than 60%) indicates that many lookup requests are not found in the Redis cache and apps are being forced to revert to slower resources. This might indicate that cached values are expiring too quickly or that a Redis instance has insufficient memory allocation and is deleting volatile keys.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: ratio <br>
      <strong>Frequency</strong>: 30s (default), 10s (configurable minimum)<br></td>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>App-specific</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: App-specific. In general depending how an app is using the cache, an expected hit ratio value can vary between 60% to 99% . Also, the same hit ratio values can mean different things for different apps. Every time an app gets a cache miss, it will probably go to and fetch the data from a slower resource. This cache miss cost can be different per app. The app developers might be able to provide a threshold that is meaningful for the app and its performance<br><br>
      <strong>Red critical</strong>: App-specific. See the warning threshold above.
   <tr>
      <th>Recommended response</th>
      <td>
        App-specific. See the warning threshold above. Work with app developers to understand the performance and cache configuration required for their apps.
      </td>
   </tr>
</table>


## <a id="bosh-health"></a> BOSH Health Monitor Metrics

<%# The below partial is in https://github.com/pivotal-cf/docs-partials %>

<%= partial vars.path_to_partials + '/services/bosh_health_metrics_pcf2' %>

## <a id="other-metrics"></a>Other Redis Metrics
Redis also exposes the following metrics. for more information, see the [Redis documentation](http://redis.io/commands/INFO).

* <code>arch\_bits</code>
* <code>uptime\_in\_seconds</code>
* <code>uptime\_in\_days</code>
* <code>hz</code>
* <code>lru\_clock</code>
* <code>client\_longest\_output\_list</code>
* <code>client\_biggest\_input\_buf</code>
* <code>used\_memory\_rss</code>
* <code>used\_memory\_peak</code>
* <code>used\_memory\_lua</code>
* <code>loading</code>
* <code>rdb\_bgsave\_in\_progress</code>
* <code>rdb\_last\_save\_time</code>
* <code>rdb\_last\_bgsave\_time\_sec</code>
* <code>rdb\_current\_bgsave\_time\_sec</code>
* <code>aof\_rewrite\_in\_progress</code>
* <code>aof\_rewrite\_scheduled</code>
* <code>aof\_last\_rewrite\_time\_sec</code>
* <code>aof\_current\_rewrite\_time\_sec</code>
* <code>total\_connections\_received</code>
* <code>total\_commands\_processed</code>
* <code>instantaneous\_ops\_per\_sec</code>
* <code>total\_net\_input\_bytes</code>
* <code>total\_net\_output\_bytes</code>
* <code>instantaneous\_input\_kbps</code>
* <code>instantaneous\_output\_kbps</code>
* <code>rejected\_connections</code>
* <code>sync\_full</code>
* <code>sync\_partial\_ok</code>
* <code>sync\_partial\_err</code>
* <code>expired\_keys</code>
* <code>evicted\_keys</code>
* <code>keyspace\_hits</code>
* <code>keyspace\_misses</code>
* <code>pubsub\_channels</code>
* <code>pubsub\_patterns</code>
* <code>latest\_fork\_usec</code>
* <code>migrate\_cached\_sockets</code>
* <code>repl\_backlog\_active</code>
* <code>repl\_backlog\_size</code>
* <code>repl\_backlog\_first\_byte\_offset</code>
* <code>repl\_backlog\_histlen</code>
* <code>used\_cpu\_sys</code>
* <code>used\_cpu\_user</code>
* <code>used\_cpu\_sys\_children</code>
* <code>used\_cpu\_user\_children</code>
* <code>rdb\_last\_bgsave\_status</code>
* <code>aof\_last\_bgrewrite\_status</code>
* <code>aof\_last\_write\_status</code>
